# -*- coding: utf-8 -*-
"""LinearregM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qMwlfsRFqG8kdyh7B8_FH0iXEo_EEANO

Simple Linear Regression
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

df = pd.read_csv("data.csv")
df

df.head()

plt.scatter(df['x'],df['y'])

plt.scatter(df['x'],df['y'])
plt.plot([min(df['x']),max(df['x'])],[min(df['y']),max(df['y'])],color="red")
plt.show()

"""Calculating Mean and Variance"""

def mean(values):
  return sum(values)/float(len(values))

def variance(values,mean):
  return sum([(x-mean)**2 for x in values])

dataset = [[1,1],[2,3],[4,3],[3,2],[5,5]]
x = [row[0] for row in dataset]
y = [row[1] for row in dataset]
mean_x, mean_y = mean(x),mean(y)
var_x,var_y =variance(x,mean_x),variance(y,mean_y)
print('x stats: mean=%.3f variance=%.3f' % (mean_x,var_x))
print('y stats: mean=%.3f variance=%.3f' % (mean_y,var_y))

"""Calculate Covariance"""

def covariance(x,mean_x,y,mean_y):
  covar = 0.0
  for i in range(len(x)):
    covar += (x[i]-mean_x)*(y[i]-mean_y)
  return covar

dataset=[[1,1],[2,3],[4,3],[3,2],[5,2]]
x = [row[0] for row in dataset]
y = [row[1] for row in dataset]
mean_x, mean_y = mean(x), mean(y)
covar = covariance( x, mean_x, y, mean_y)
print('Covariannce: %.3f' % (covar))

"""Estimate Coefficients"""

def Coefficients(dataset):
  x = [row[0] for row in dataset]
  y = [row[1] for row in dataset]
  x_mean, y_mean = mean(x), mean(y)
  b1 = covariance( x, mean_x, y, mean_y) / variance(x,x_mean)
  b0 = y_mean - b1* x_mean
  return [b0,b1]

dataset=[[1,1],[2,3],[4,3],[3,2],[5,2]]
b0,b1 = Coefficients(dataset)
print('Coeffecients: b0=%.3f,b1=%.3f' % (b0,b1))

"""Make Predictions"""

def simple_linear_regression(train, test) :
  predictions = list()
  b0, b1 = Coefficients(train)
  print("Parameters estimated using OLS:")
  print("b0=",b0,"b1=",b1)
  for row in test:
    yhat = b0+b1*row[0]
    predictions.append(yhat)
  return predictions

from math import sqrt

"""calculate root mean squared error"""

def rmse_metric(actual,predicted):
  sum_error = 0.0
  for i in range(len(actual)):
    prediction_error =predicted[i] - actual[i]
    sum_error += (prediction_error ** 2)
  mean_error = sum_error / float(len(actual))
  return sqrt(mean_error)

"""Evaluate regression algorithm on training dataset"""

def evaluate_algorithm(dataset,algorithm):
  test_set = list()
  for row in dataset:
    row_copy = list(row)
    row_copy[-1] =None
    test_set.append(row_copy)
  predicted =algorithm(dataset,test_set)
  actual = [row[-1] for row in dataset]
  rmse = rmse_metric(actual,predicted)
  return rmse,predicted

"""Test simple linear regression"""

dataset=[[1,1],[2,3],[4,3],[3,2],[5,2]]
y_pred =[]
rmse,y_pred = evaluate_algorithm(dataset,simple_linear_regression)
print('RMSE: %.3f' % (rmse))
print(y_pred)

"""Predict Insurance"""

data = df.values
data

y_pred = []
rmse,y_pred = evaluate_algorithm(dataset,simple_linear_regression)
print('RMSE: %.3f' % (rmse))
print(y_pred)

plt.scatter(df['x'],df['y'])
plt.plot([min(df['x']),max(df['x'])],[min(df['y']),max(df['y'])],color="red")
plt.show()

"""Gradient Descent for Parameter Estimatiom"""

def Gradient_descent(x,y,b1_current=0,b0_current=0,epochs=1000,learning_rate=0.0001):
  N=float(len(y))
  for i in range(epochs):
    y_current =(b1_current *~ x) + b0_current
    b1_gradient = -(2/N) * sum(x * (y-y_current))
    b0_gradient = -(2/N) * sum(y-y_current)
    b1_current = b1_current  - (learning_rate * b1_gradient)
    b0_current = b0_current  - (learning_rate * b0_gradient)
  return b0_current,b1_current

b0,b1 = Gradient_descent(df['x'],df['y'])
print(b0,b1)

from re import X
predications =[]
for x in df['x']:
  yp = b0 + b1*X
  predications.append(yp)
print(predications)

rmse = rmse_metric(df['y'],predications)
print('RMSE: %.3f' % (rmse))

plt.scatter(df['x'],df['y'])
plt.plot([min(df['x']),max(df['x'])],[min(df['y']),max(df['y'])],color="red")
plt.show()

